
<link rel="stylesheet" href="/pl2/css/friendly.css" />

<link rel="stylesheet" href="/pl2/css/lecture-style.css" />

<meta charset="utf-8" />

<h3 id="more-functional-programming-in-ocaml">More Functional Programming in OCaml</h3>

<ul>
  <li>There are “nearly infinitely many” features we skipped in PL I and we are not going to cover all of them</li>
  <li>But let us cover a few, as a warm-up if nothing else</li>
</ul>

<h4 id="pipelining">Pipelining</h4>

<ul>
  <li>In *nix shell, each command can be viewed as a function from stdin to stdout</li>
  <li><code class="highlighter-rouge">blah | blahblah</code> takes the output of <code class="highlighter-rouge">blah</code> and feeds it as input to <code class="highlighter-rouge">blahblah</code></li>
  <li>Reminder on how it is useful:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>blah.tar.gz | <span class="nb">gunzip</span> | <span class="nb">tar </span>tf - | <span class="nb">cat</span> | <span class="nb">grep</span> .md
</code></pre></div></div>

<ul>
  <li>OCaml version is <code class="highlighter-rouge">|&gt;</code></li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">(</span><span class="o">|&gt;</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="bp">[]</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">cons</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">cons</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">cat</code> in *nix is like <code class="highlighter-rouge">fun x -&gt; x</code> in OCaml</li>
  <li>Associates left like shell pipe</li>
  <li>Related to messsage chaining in OO languages</li>
</ul>

<h4 id="folds-and-generalized-folds">Folds and generalized folds</h4>

<p>We will roughly follow the <a href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/hop/intro.html">Cornell notes</a></p>

<h5 id="fold-right">Fold right</h5>

<ul>
  <li>The function <code class="highlighter-rouge">List.fold_right</code> in OCaml “folds” a list to a single element via an operation.</li>
  <li>Example:
    <div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span> <span class="o">*</span> <span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">]</span> <span class="mi">1</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>is <code class="highlighter-rouge">2*(5*(7*(1)))</code>, i.e. <code class="highlighter-rouge">70</code>.  The “right” refers to the zero (<code class="highlighter-rouge">1</code> here) being on the right, not the left (it doesn’t matter in the case of multiplication as it is associative).</p>

<p>Here is roughly how <code class="highlighter-rouge">List.fold_right</code> is implemented:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_right</span> <span class="n">op</span> <span class="n">lst</span> <span class="n">init</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">op</span> <span class="n">h</span> <span class="p">(</span><span class="n">fold_right</span> <span class="n">op</span> <span class="n">t</span> <span class="n">init</span><span class="p">)</span>

<span class="k">let</span> <span class="n">summate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">lst</span> <span class="mi">0</span>
<span class="k">let</span> <span class="n">concatenate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="n">lst</span> <span class="s2">""</span>
</code></pre></div></div>

<ul>
  <li>Actually writing out <code class="highlighter-rouge">summate</code> as a recursive function isn’t going to save many lines, but it gets the code on a “higher level” so is often good practice.</li>
  <li>It is similar in spirit to dot product in linear algebra: define things in terms of higher-level math operations, don’t re-define from scratch.</li>
</ul>

<h5 id="fold-left">Fold left</h5>

<ul>
  <li>Folding left is the same idea but the “zero” is on the left:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span> <span class="o">*</span> <span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">]</span> <span class="c">(* note the zero and the list swapped in arg list vs folds_right *)</span>
</code></pre></div></div>

<p>is <code class="highlighter-rouge">(((1)*2)*5)*7</code>, i.e. <code class="highlighter-rouge">70</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_left</span> <span class="n">op</span> <span class="n">accum</span> <span class="n">lst</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">accum</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fold_left</span> <span class="n">op</span> <span class="p">(</span><span class="n">op</span> <span class="n">accum</span> <span class="n">h</span><span class="p">)</span> <span class="n">t</span>

<span class="k">let</span> <span class="n">summate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">lst</span>
<span class="k">let</span> <span class="n">concatenate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="s2">""</span> <span class="n">lst</span>
</code></pre></div></div>

<ul>
  <li>Observe that since addition and concatenation are both associative that fold left and right give the same result in the above.</li>
  <li>But, use <code class="highlighter-rouge">List.fold_left</code> by default, it is more efficient</li>
  <li>Why is it more efficient?  Observe all recursive calls don’t need to return really, at the rec-call point the function is done</li>
  <li>Such recursion can be turned into a loop by an optimizing compiler, so-called <em>tail-call elimination</em>.</li>
</ul>

<h5 id="length-map-reverse-and-filter-can-be-coded-just-with-a-fold">length, map, reverse, and filter can be coded just with a fold!</h5>

<p>Here are some pleasant examples mostly from the Cornell notes illustrating the power of fold.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="n">l</span>
<span class="k">let</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">::</span><span class="n">a</span><span class="p">)</span> <span class="bp">[]</span> <span class="n">l</span> <span class="c">(* e.g. rev [1;2;3] = (3::(2::(1::[]))) *)</span>
<span class="k">let</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span><span class="o">::</span><span class="n">a</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span>
<span class="k">let</span> <span class="n">map_rev</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span><span class="o">::</span><span class="n">a</span><span class="p">)</span>  <span class="bp">[]</span> <span class="n">l</span>
<span class="k">let</span> <span class="n">filter</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="n">x</span><span class="o">::</span><span class="n">a</span> <span class="k">else</span> <span class="n">a</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span>
</code></pre></div></div>

<h5 id="fold-on-trees">Fold on trees</h5>

<ul>
  <li>What is fold on lists doing?  Visit all the elements applying an accumulating operator</li>
  <li>Tree fold is to do the same thing on a tree structure</li>
  <li>Here is a simple example from the Cornell notes.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">=</span> 
<span class="o">|</span> <span class="nc">Leaf</span> 
<span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">treefold</span> <span class="n">init</span> <span class="n">op</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="p">(</span><span class="n">v</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">op</span> <span class="n">v</span> <span class="p">(</span><span class="n">treefold</span> <span class="n">init</span> <span class="n">op</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">treefold</span> <span class="n">init</span> <span class="n">op</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">size</span> <span class="n">t</span> <span class="o">=</span> <span class="n">treefold</span> <span class="mi">0</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="n">t</span>
<span class="k">let</span> <span class="n">depth</span> <span class="n">t</span> <span class="o">=</span> <span class="n">treefold</span> <span class="mi">0</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="n">t</span>
<span class="k">let</span> <span class="n">preorder</span> <span class="n">t</span> <span class="o">=</span> <span class="n">treefold</span> <span class="bp">[]</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">l</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">@</span> <span class="n">l</span> <span class="o">@</span> <span class="n">r</span><span class="p">)</span> <span class="n">t</span>
<span class="k">let</span> <span class="n">tex</span> <span class="o">=</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">6</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">))</span>
<span class="n">size</span> <span class="n">tex</span>
</code></pre></div></div>

<h5 id="catamorphisms">Catamorphisms</h5>

<ul>
  <li>This is a fancy word for a fold over any data type.</li>
  <li>Well it is actually a little cooler than that, there is some elegant math behind it which we are skipping.</li>
  <li>The general principle for any datatype is to accumulate results from the “rest” of the data type tree and “compose” with the current node.</li>
</ul>

<p>Treefold re-cast slightly more generically</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">generic_treefold</span> <span class="p">(</span><span class="n">i</span><span class="o">,</span><span class="n">f</span><span class="p">)</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">i</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="p">(</span><span class="n">v</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">v</span> <span class="p">(</span><span class="n">generic_treefold</span> <span class="p">(</span><span class="n">i</span><span class="o">,</span><span class="n">f</span><span class="p">)</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">generic_treefold</span> <span class="p">(</span><span class="n">i</span><span class="o">,</span><span class="n">f</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span>

<span class="k">let</span> <span class="n">size</span> <span class="n">t</span> <span class="o">=</span> <span class="n">generic_treefold</span> <span class="p">(</span><span class="mi">0</span><span class="o">,</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">))</span> <span class="n">t</span>
</code></pre></div></div>

<ul>
  <li>In general, the tuple <code class="highlighter-rouge">(i,f)</code> can generalize to composers over all the cases of the datatype.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">expr</span> <span class="o">=</span> 
<span class="o">|</span> <span class="nc">Var</span> <span class="k">of</span> <span class="kt">string</span>
<span class="o">|</span> <span class="nc">Func</span> <span class="k">of</span> <span class="kt">string</span> <span class="o">*</span> <span class="n">expr</span>
<span class="o">|</span> <span class="nc">Appl</span> <span class="k">of</span> <span class="n">expr</span> <span class="o">*</span> <span class="n">expr</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">exprfold</span> <span class="p">(</span><span class="n">va</span><span class="o">,</span><span class="n">fu</span><span class="o">,</span><span class="n">ap</span><span class="p">)</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Var</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">va</span> <span class="n">s</span>
  <span class="o">|</span> <span class="nc">Func</span><span class="p">(</span><span class="n">v</span><span class="o">,</span><span class="n">e</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">fu</span> <span class="n">v</span> <span class="p">(</span><span class="n">exprfold</span> <span class="p">(</span><span class="n">va</span><span class="o">,</span><span class="n">fu</span><span class="o">,</span><span class="n">ap</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span>
  <span class="o">|</span> <span class="nc">Appl</span><span class="p">(</span><span class="n">e</span><span class="o">,</span><span class="n">e'</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ap</span> <span class="p">(</span><span class="n">exprfold</span> <span class="p">(</span><span class="n">va</span><span class="o">,</span><span class="n">fu</span><span class="o">,</span><span class="n">ap</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="p">(</span><span class="n">exprfold</span> <span class="p">(</span><span class="n">va</span><span class="o">,</span><span class="n">fu</span><span class="o">,</span><span class="n">ap</span><span class="p">)</span> <span class="n">e'</span><span class="p">)</span>

<span class="k">let</span> <span class="n">allvaroccs</span> <span class="n">e</span> <span class="o">=</span> <span class="n">exprfold</span> <span class="p">((</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="o">,</span><span class="p">(</span><span class="k">fun</span> <span class="n">v</span> <span class="n">fo</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">::</span> <span class="n">fo</span><span class="p">)</span><span class="o">,</span> <span class="p">(</span><span class="k">fun</span> <span class="n">fo1</span> <span class="n">fo2</span> <span class="o">-&gt;</span> <span class="n">fo1</span> <span class="o">@</span> <span class="n">fo2</span><span class="p">))</span> <span class="n">e</span>

<span class="k">let</span> <span class="n">testexpr</span> <span class="o">=</span> <span class="nc">Appl</span><span class="p">(</span><span class="nc">Func</span><span class="p">(</span><span class="s2">"x"</span><span class="o">,</span><span class="nc">Var</span> <span class="s2">"x"</span><span class="p">)</span><span class="o">,</span><span class="nc">Var</span> <span class="s2">"y"</span><span class="p">)</span>

<span class="n">allvaroccs</span> <span class="n">testexpr</span>
</code></pre></div></div>

<ul>
  <li>It is not worth getting <em>too</em> excited by this stuff as many functions on data structures are not just a simple fold.</li>
  <li>Example: determining if an expression in the above language is closed is impossible with <code class="highlighter-rouge">exprfold</code></li>
</ul>

<h4 id="ocaml-functors">OCaml functors</h4>

<ul>
  <li>A “function” from structures to structures</li>
  <li>Allows a module to be parameterized and so instantiated in multiple ways
    <ul>
      <li>think of it as the ability to “plug in” a code module</li>
    </ul>
  </li>
  <li>General functors are found only in a few languages</li>
</ul>

<p>Here is a kind of struct that we can take as a parameter</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">comparison</span> <span class="o">=</span> <span class="nc">LessThan</span> <span class="o">|</span> <span class="nc">EqualTo</span> <span class="o">|</span> <span class="nc">GreaterThan</span> 
 
<span class="k">module</span> <span class="k">type</span> <span class="nc">ORDERED_TYPE</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compare</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">comparison</span>
  <span class="k">end</span><span class="p">;;</span>
</code></pre></div></div>

<p>Here is a functor version of a set, you feed in a struct with the set element ordering defined on it</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">FSetFunctor</span> <span class="o">=</span>
  <span class="k">functor</span> <span class="p">(</span><span class="nc">Elt</span><span class="o">:</span> <span class="nc">ORDERED_TYPE</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="k">struct</span>
    <span class="k">type</span> <span class="n">element</span> <span class="o">=</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">t</span> <span class="c">(* import the type of elements from the structure *)</span>
    <span class="k">type</span> <span class="n">set</span> <span class="o">=</span> <span class="n">element</span> <span class="kt">list</span>

    <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="bp">[]</span>

    <span class="k">let</span> <span class="k">rec</span> <span class="n">add</span> <span class="n">x</span> <span class="n">s</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
        <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
      <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span>
          <span class="k">match</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">hd</span> <span class="k">with</span>
            <span class="nc">EqualTo</span>   <span class="o">-&gt;</span> <span class="n">s</span>
          <span class="o">|</span> <span class="nc">LessThan</span>    <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">s</span>
          <span class="o">|</span> <span class="nc">GreaterThan</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">add</span> <span class="n">x</span> <span class="n">tl</span>

    <span class="k">let</span> <span class="k">rec</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">s</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
        <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
      <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span>
          <span class="k">match</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">hd</span> <span class="k">with</span>
            <span class="nc">EqualTo</span>   <span class="o">-&gt;</span> <span class="bp">true</span>
          <span class="o">|</span> <span class="nc">LessThan</span>    <span class="o">-&gt;</span> <span class="bp">false</span>
          <span class="o">|</span> <span class="nc">GreaterThan</span> <span class="o">-&gt;</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">tl</span>
  <span class="k">end</span><span class="p">;;</span>
</code></pre></div></div>

<p>Here is a concrete ordering we can feed in, one over ints</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">OrderedInt</span> <span class="o">=</span>
  <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
    <span class="k">let</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">then</span>
    <span class="nc">EqualTo</span>
      <span class="k">else</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span>
      <span class="nc">LessThan</span>
    <span class="k">else</span>
      <span class="nc">GreaterThan</span>
  <span class="k">end</span><span class="p">;;</span>
</code></pre></div></div>

<p>Here is how we feed it in, instantiating the functor to give a structure</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">OrderedIntSet</span> <span class="o">=</span> <span class="nc">FSetFunctor</span><span class="p">(</span><span class="nc">OrderedInt</span><span class="p">);</span>
</code></pre></div></div>

<p>Example of using the resulting module</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">myOrderedIntSet</span> <span class="o">=</span> <span class="nn">OrderedIntSet</span><span class="p">.</span><span class="n">add</span> <span class="mi">5</span> <span class="nn">OrderedIntSet</span><span class="p">.</span><span class="n">empty</span><span class="p">;;</span>
<span class="nn">OrderedIntSet</span><span class="p">.</span><span class="n">contains</span> <span class="mi">3</span> <span class="n">myOrderedIntSet</span><span class="p">;;</span>
</code></pre></div></div>

<p>We can do the same thing for a string comparison</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">OrderedString</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span>
  <span class="k">let</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">EqualTo</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">LessThan</span>
    <span class="k">else</span> <span class="nc">GreaterThan</span>
<span class="k">end</span><span class="p">;;</span>

<span class="k">module</span> <span class="nc">OrderedStringSet</span> <span class="o">=</span> <span class="nc">FSetFunctor</span><span class="p">(</span><span class="nc">OrderedString</span><span class="p">);;</span> <span class="c">(* a DIFFERENT instantiation of same *)</span>

<span class="k">let</span> <span class="n">myOrderedStringSet</span> <span class="o">=</span> <span class="nn">OrderedStringSet</span><span class="p">.</span><span class="n">add</span> <span class="s2">"abc"</span> <span class="nn">OrderedStringSet</span><span class="p">.</span><span class="n">empty</span><span class="p">;;</span>
</code></pre></div></div>

<p>Functors also have signatures; there can also be type abstraction in a functor signature</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">SETFUNCTOR</span> <span class="o">=</span> <span class="c">(* below is the syntax for a signature of a functor *)</span>
    <span class="k">functor</span> <span class="p">(</span><span class="nc">Elt</span><span class="o">:</span> <span class="nc">ORDERED_TYPE</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">element</span> <span class="o">=</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">t</span>      <span class="c">(* concrete *)</span>
    <span class="k">type</span> <span class="n">set</span>                  <span class="c">(* abstract *)</span>
    <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">set</span>
    <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="o">-&gt;</span> <span class="n">set</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">end</span><span class="p">;;</span>

<span class="k">module</span> <span class="nc">AbstractSet</span> <span class="o">=</span> <span class="p">(</span><span class="nc">FSetFunctor</span> <span class="o">:</span> <span class="nc">SETFUNCTOR</span><span class="p">);;</span> <span class="c">(* slap that sig on a functor *)</span>
<span class="k">module</span> <span class="nc">AbstractIntSet</span> <span class="o">=</span> <span class="nc">AbstractSet</span><span class="p">(</span><span class="nc">OrderedInt</span><span class="p">);;</span>

<span class="nn">AbstractIntSet</span><span class="p">.</span><span class="n">add</span> <span class="mi">5</span> <span class="nn">AbstractIntSet</span><span class="p">.</span><span class="n">empty</span><span class="p">;;</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="highlighter-rouge">Stdlib.Set</code> uses functors, let us review it – <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.html">manpage</a></p>
  </li>
  <li>
    <p><a href="https://dev.realworldocaml.org/functors.html">Real World OCaml</a> has more involved examples</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">fbdk/src/application.ml</code> in FbDK is yet another example; e.g. <code class="highlighter-rouge">Fb/fb.ml</code> uses the functor.</p>
  </li>
</ul>

<h5 id="first-class-modules">First-class modules</h5>

<p>Idea: Lift modules to be true first-class data; supported in more recent OCaml versions.</p>

<ul>
  <li>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual028.html">the manual</a> for documentation</li>
  <li>Allows modules to be constructed and composed based on run-time data</li>
  <li>Allows modules to be placed in data structures, e.g. a list of Set’s.</li>
  <li>Allows functors to be written which are ordinary functions (not as powerful as actual functors though)</li>
  <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual028.html">Example in OCaml manual</a> shows how to build a Set-making function</li>
  <li>See <a href="https://dev.realworldocaml.org/first-class-modules.html">Real-World OCaml</a> for more info on first-class modules, the manual is pretty minimal</li>
</ul>

<h5 id="background-basic-type-theory">Background: Basic Type Theory</h5>

<p>Before getting into functors and GADTs, review forall, exists, and higher kinded (types as values) <br />
types.</p>

<ul>
  <li>Polymorphic types inferred in OCaml are forall types</li>
  <li>Parameters on type definitions are defining type-valued functions (which are not OCaml functions – “not first-class”)</li>
  <li>Hidden / abstract types in module signatures are exists types: holds for some type</li>
  <li>New features of OCaml covered here have other fancy types; each one is either a forall, exists, or type-as-value usage.</li>
</ul>

<h4 id="gadts-in-ocaml">GADTs in OCaml</h4>

<p>Lists manually using existing OCaml types</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">oldlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">oldlist</span>
</code></pre></div></div>

<p>Think of this as a type-valued function: given a type <code class="highlighter-rouge">'a</code> we get a type out: it is “really”</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">oldlist</span> <span class="o">=</span> <span class="n">typefun</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nc">Nil</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="n">oldlist</span><span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span><span class="p">))</span>
</code></pre></div></div>

<p>Equivalent way to do list type using new generic type syntax (but using it to do old thing)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
<span class="o">|</span> <span class="nc">Cons</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
</code></pre></div></div>
<p>(the <code class="highlighter-rouge">_</code> here could also be <code class="highlighter-rouge">'a</code>, you probably want to view it as <code class="highlighter-rouge">'a</code> in fact)</p>

<p>Observe how this is writing out the constructors with what their types are, viewing constructors as functions (they still are not functions in OCaml, but they are closer to being so)</p>

<p>Lets now show some added power of this new notation (toy example).</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
<span class="o">|</span> <span class="nc">IntNil</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">newlist</span>
<span class="o">|</span> <span class="nc">Cons</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
</code></pre></div></div>

<p>We now have a new IntNil empty list, which is only consable on to integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">IntNil</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">IntNil</span><span class="p">)</span>
</code></pre></div></div>

<p>Note however that “IntNil” is just a name, the int newlist type could have been something else:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
<span class="o">|</span> <span class="nc">IntNil</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">newlist</span> <span class="c">(* yes this is perfectly legal *)</span>
<span class="o">|</span> <span class="nc">Cons</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">IntNil</span><span class="p">);;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">string</span> <span class="n">newlist</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">newlist</span>
       <span class="nc">Type</span> <span class="kt">string</span> <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="kt">int</span>
</code></pre></div></div>

<p>In other words, the “IntNil” is just a name.  It is <em>axiomatically</em> (by fiat) making certain constructors have certain newlist types.  Think of it as something like making an operational semantics rule set.  Here is an arbitrary example to illustrate.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">dough</span> <span class="o">=</span> 
  <span class="nc">Coin</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="c">(* base case (axiom) *)</span>
<span class="o">|</span> <span class="nc">Add</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="c">(* rule: have dough, can make more same type of dough *)</span>
<span class="o">|</span> <span class="nc">Bump</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="n">dough</span> <span class="c">(* rule: can turn int dough to float dough *)</span>
<span class="o">|</span> <span class="nc">Morph</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">dough</span> <span class="c">(* rule: can turn any kind of dough to any other *)</span>
<span class="o">|</span> <span class="nc">Intbux</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">dough</span> <span class="c">(* rule: with a number some int dough can be made *)</span>
<span class="o">|</span> <span class="nc">Intcomb</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">dough</span> <span class="c">(* rule: use int and int dough to make int dough *)</span>
</code></pre></div></div>

<p>You can still do whatever combinations will type, e.g.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">Bump</span><span class="p">(</span><span class="nc">Add</span><span class="p">(</span><span class="nc">Coin</span><span class="p">));;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">dough</span> <span class="o">=</span> <span class="nc">Bump</span> <span class="p">(</span><span class="nc">Add</span> <span class="nc">Coin</span><span class="p">)</span>
<span class="o">#</span> <span class="nc">Bump</span><span class="p">(</span><span class="nc">Morph</span><span class="p">(</span><span class="nc">Bump</span><span class="p">(</span><span class="nc">Add</span><span class="p">(</span><span class="nc">Intcomb</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">Coin</span><span class="p">)))));;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">dough</span> <span class="o">=</span> <span class="nc">Bump</span> <span class="p">(</span><span class="nc">Morph</span> <span class="p">(</span><span class="nc">Bump</span> <span class="p">(</span><span class="nc">Add</span> <span class="p">(</span><span class="nc">Intcomb</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Coin</span><span class="p">)))))</span>
</code></pre></div></div>

<p>This particular type has no purpose: it is like making some random (well-formed) operational semantics rules, they are not likely to be useful.  As with an operational semantics rule set, with the right set of rules you can do interesting stuff.</p>

<p>Here is an example from the manual showing how some useful work can be done.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">type</span> <span class="n">_</span> <span class="n">typ</span> <span class="o">=</span>
   <span class="o">|</span> <span class="nc">Int</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span>      <span class="c">(* axiom: make an int type *)</span>
   <span class="o">|</span> <span class="nc">String</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">typ</span> <span class="c">(* axiom: can make a string typ *)</span>
   <span class="o">|</span> <span class="nc">Pair</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">typ</span> <span class="c">(* rule: from any two typ's can make their product *)</span>
</code></pre></div></div>

<p>Observe first that this GADT <code class="highlighter-rouge">typ</code> is not the same as the “old OCaml” equivalent,</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">atype</span> <span class="o">=</span> <span class="nc">OInt</span> <span class="o">|</span> <span class="nc">OString</span> <span class="o">|</span> <span class="nc">OPair</span> <span class="k">of</span> <span class="n">atype</span> <span class="o">*</span> <span class="n">atype</span>
</code></pre></div></div>
<p>– the old types are much simpler, there is no type parameter; compare:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">OPair</span><span class="p">(</span><span class="nc">OInt</span><span class="o">,</span><span class="nc">OString</span><span class="p">);;</span> <span class="c">(* old *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">atype</span> <span class="o">=</span> <span class="nc">OPair</span> <span class="p">(</span><span class="nc">OInt</span><span class="o">,</span> <span class="nc">OString</span><span class="p">)</span>           <span class="c">(* no parameter on atype *)</span>
<span class="o">#</span> <span class="nc">Pair</span><span class="p">(</span><span class="nc">Int</span><span class="o">,</span><span class="nc">String</span><span class="p">);;</span>    <span class="c">(* new *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span><span class="p">)</span> <span class="n">typ</span> <span class="o">=</span> <span class="nc">Pair</span> <span class="p">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">String</span><span class="p">)</span> <span class="c">(* observe parameter on typ *)</span>
</code></pre></div></div>

<p>The interesting and useful bit about this seemingly-useless difference is this type parameter on <code class="highlighter-rouge">typ</code> can be used to force typings to go a certain way:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="k">rec</span> <span class="n">to_string</span><span class="o">:</span> <span class="k">type</span> <span class="n">t</span><span class="o">.</span> <span class="n">t</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span>
   <span class="k">fun</span> <span class="n">tv</span> <span class="n">x</span> <span class="o">-&gt;</span>
   <span class="k">match</span> <span class="n">tv</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Int</span> <span class="o">-&gt;</span> <span class="n">string_of_int</span> <span class="n">x</span>
   <span class="o">|</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"%S"</span> <span class="n">x</span>
   <span class="o">|</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">let</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="k">in</span>
       <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"(%s,%s)"</span> <span class="p">(</span><span class="n">to_string</span> <span class="n">t1</span> <span class="n">x1</span><span class="p">)</span> <span class="p">(</span><span class="n">to_string</span> <span class="n">t2</span> <span class="n">x2</span><span class="p">)</span>
</code></pre></div></div>

<p>Here <code class="highlighter-rouge">typ</code> is giving a run-time name, <code class="highlighter-rouge">Int</code> which in the type of <code class="highlighter-rouge">to_string</code> adds an implicit constraint that the second argument <em>must be an integer</em> (cool, eh?).  This allows run-time type dispatch to be encoded; this trick is in fact how the OCaml libraries implement printf.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># to_string Int 5;;
- : string = "5"
# to_string Int "oops";;
Error: This expression has type string but an expression was expected of type
         int
</code></pre></div></div>

<p>Notice also the special new <code class="highlighter-rouge">type t.</code> syntax for the type argument (which must be declared, inference is stupid for GADT types).  This shows what GADTs are useful for: the type <code class="highlighter-rouge">t</code> can be viewed as an (implicit) parameter to this function.  If the type were the more standard OCaml <code class="highlighter-rouge">'a typ -&gt; 'a -&gt; string</code> this would require <code class="highlighter-rouge">'a</code> to be <em>generic</em> and since the body de facto cases on that type this standard typing would not work.</p>

<p>Notice also that any cases from a GADT which do not type-check can be elided since the type system knows that case will never be matched – the following typechecks:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">int_to_string</span><span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span>
   <span class="k">fun</span> <span class="n">t</span> <span class="n">x</span> <span class="o">-&gt;</span>
   <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Int</span> <span class="o">-&gt;</span> <span class="n">string_of_int</span> <span class="n">x</span>
</code></pre></div></div>

<p>Here is another simple example.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">wait</span> <span class="o">=</span>  <span class="nc">Wait</span> <span class="o">:</span> <span class="k">'</span><span class="n">arg</span> <span class="o">*</span> <span class="p">(</span><span class="k">'</span><span class="n">arg</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">result</span> <span class="n">wait</span>
<span class="k">let</span> <span class="n">foo</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
<span class="k">let</span> <span class="n">suspended_value</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">wait</span> <span class="o">=</span> <span class="nc">Wait</span><span class="p">(</span><span class="bp">true</span><span class="o">,</span> <span class="n">foo</span><span class="p">)</span>
<span class="k">let</span> <span class="n">other_suspended_value</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">wait</span> <span class="o">=</span> <span class="nc">Wait</span><span class="p">(</span><span class="s2">"5"</span><span class="o">,</span> <span class="n">int_of_string</span><span class="p">)</span>
<span class="k">let</span> <span class="n">run_it</span> <span class="n">w</span> <span class="o">=</span> <span class="k">match</span> <span class="n">w</span> <span class="k">with</span> <span class="nc">Wait</span><span class="p">(</span><span class="n">arg</span><span class="o">,</span><span class="n">func</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">func</span> <span class="n">arg</span>
<span class="k">let</span> <span class="n">doit</span> <span class="o">=</span> <span class="n">run_it</span> <span class="n">suspended_value</span>
</code></pre></div></div>

<p>Observe that the type <code class="highlighter-rouge">'arg</code> is not an exposed parameter in the wait type like <code class="highlighter-rouge">'result</code> is, it is an <em>existential</em> type, there is <em>some</em> type that works there but it is from the <code class="highlighter-rouge">wait</code> type.</p>

<p>A practical library example: <a href="https://github.com/hannesm/gmap">Gmap</a></p>

