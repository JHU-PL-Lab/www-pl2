
<link rel="stylesheet" href="/pl2/css/friendly.css" />

<link rel="stylesheet" href="/pl2/css/lecture-style.css" />

<meta charset="utf-8" />

<h3 id="more-functional-programming-in-ocaml">More Functional Programming in OCaml</h3>

<ul>
  <li>There are “nearly infinitely many” OCaml features we skipped in PL I and we are not going to cover all of them</li>
  <li>But let us cover a few, as a warm-up if nothing else</li>
</ul>

<h4 id="pipelining">Pipelining</h4>

<ul>
  <li>In *nix shell, each command can be viewed as a function from stdin to stdout</li>
  <li><code class="highlighter-rouge">blah | blahblah</code> takes the output of <code class="highlighter-rouge">blah</code> and feeds it as input to <code class="highlighter-rouge">blahblah</code></li>
  <li>Reminder on how it is useful:</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>blah.tar.gz | <span class="nb">gunzip</span> | <span class="nb">tar </span>tf - | <span class="nb">cat</span> | <span class="nb">grep</span> .md
</code></pre></div></div>

<ul>
  <li>OCaml version is <code class="highlighter-rouge">|&gt;</code></li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="p">(</span><span class="o">|&gt;</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="mi">5</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">20</span><span class="p">);;</span> <span class="c">(* it is really just new syntax for function application *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">15</span>
<span class="o">#</span> <span class="bp">[]</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">cons</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="nn">List</span><span class="p">.</span><span class="n">cons</span> <span class="mi">7</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span><span class="p">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">2</span>
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">cat</code> in *nix is like <code class="highlighter-rouge">fun x -&gt; x</code> in OCaml</li>
  <li>Associates left like shell pipe</li>
  <li>Related to messsage chaining in OO languages</li>
</ul>

<h4 id="folds-and-generalized-folds">Folds and generalized folds</h4>

<p>We will roughly follow the <a href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/hop/intro.html">Cornell notes</a></p>

<h5 id="fold-right">Fold right</h5>

<ul>
  <li>The function <code class="highlighter-rouge">List.fold_right</code> in OCaml “folds” a list to a single element via an operation.</li>
  <li>Example:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span> <span class="o">*</span> <span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">]</span> <span class="mi">1</span>
</code></pre></div></div>

<p>is <code class="highlighter-rouge">2*(5*(7*(1)))</code>, i.e. <code class="highlighter-rouge">70</code>.  The “right” refers to the zero (<code class="highlighter-rouge">1</code> here) being on the right, not the left (it doesn’t matter in the case of multiplication as it is commutative and associative).</p>

<p>Here is roughly how <code class="highlighter-rouge">List.fold_right</code> is implemented:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_right</span> <span class="n">op</span> <span class="n">lst</span> <span class="n">init</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">op</span> <span class="n">h</span> <span class="p">(</span><span class="n">fold_right</span> <span class="n">op</span> <span class="n">t</span> <span class="n">init</span><span class="p">)</span>

<span class="k">let</span> <span class="n">summate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">lst</span> <span class="mi">0</span>
<span class="k">let</span> <span class="n">concatenate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="n">lst</span> <span class="s2">""</span>
</code></pre></div></div>

<ul>
  <li>Actually writing out <code class="highlighter-rouge">summate</code> as a recursive function isn’t going to be much longer, but it gets the code on a “higher level” so is often good practice.</li>
  <li>Analogy with e.g. dot product in linear algebra: define things in terms of higher-level math operations, don’t re-define from scratch.</li>
</ul>

<h5 id="fold-left">Fold left</h5>

<ul>
  <li>Folding left is the same idea but the “zero” is on the left:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span> <span class="o">*</span> <span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">]</span> <span class="c">(* note the zero and the list swapped in arg list vs folds_right *)</span>
</code></pre></div></div>

<p>is <code class="highlighter-rouge">(((1)*2)*5)*7</code>, i.e. <code class="highlighter-rouge">70</code>.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">fold_left</span> <span class="n">op</span> <span class="n">accum</span> <span class="n">lst</span> <span class="o">=</span> <span class="k">match</span> <span class="n">lst</span> <span class="k">with</span>
  <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">accum</span>
  <span class="o">|</span> <span class="n">h</span><span class="o">::</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="n">fold_left</span> <span class="n">op</span> <span class="p">(</span><span class="n">op</span> <span class="n">accum</span> <span class="n">h</span><span class="p">)</span> <span class="n">t</span>

<span class="k">let</span> <span class="n">summate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">lst</span>
<span class="k">let</span> <span class="n">concatenate</span> <span class="n">lst</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="o">^</span><span class="p">)</span> <span class="s2">""</span> <span class="n">lst</span>
</code></pre></div></div>

<ul>
  <li>Observe that since addition and concatenation are both commutative and associative that fold left and right give the same result in the above.</li>
  <li>But, use <code class="highlighter-rouge">List.fold_left</code> by default, it is more efficient</li>
  <li>Why is it more efficient?  Observe all recursive calls don’t need to return really, at the rec-call point the function is done</li>
  <li>Such recursion can be turned into a loop by an optimizing compiler, so-called <em>tail-call elimination</em>.</li>
</ul>

<p>Some non-assoc/commut operator:</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">]</span> <span class="mi">0</span>     <span class="c">(* 2-(5-(7-0))) = 4; not very useful *)</span>
<span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span> <span class="mi">5</span><span class="p">;</span> <span class="mi">7</span><span class="p">]</span>      <span class="c">(* ((0-2)-5)-7 = -14 *)</span>
</code></pre></div></div>

<h5 id="length-map-reverse-and-filter-can-be-coded-just-with-a-fold">length, map, reverse, and filter can be coded just with a fold!</h5>

<p>Here are some pleasant examples mostly from the Cornell notes illustrating the power of fold.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">length</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="n">l</span>
<span class="k">let</span> <span class="n">rev</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">::</span><span class="n">a</span><span class="p">)</span> <span class="bp">[]</span> <span class="n">l</span> <span class="c">(* e.g. rev [1;2;3] = (3::(2::(1::[]))) *)</span>
<span class="k">let</span> <span class="n">map</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span><span class="o">::</span><span class="n">a</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span>
<span class="k">let</span> <span class="n">map_rev</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_left</span> <span class="p">(</span><span class="k">fun</span> <span class="n">a</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span><span class="o">::</span><span class="n">a</span><span class="p">)</span>  <span class="bp">[]</span> <span class="n">l</span> <span class="c">(* to contrast left and right fold *)</span>
<span class="k">let</span> <span class="n">filter</span> <span class="n">f</span> <span class="n">l</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">fold_right</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">f</span> <span class="n">x</span> <span class="k">then</span> <span class="n">x</span><span class="o">::</span><span class="n">a</span> <span class="k">else</span> <span class="n">a</span><span class="p">)</span> <span class="n">l</span> <span class="bp">[]</span>
</code></pre></div></div>

<h5 id="fold-on-trees">Fold on trees</h5>

<ul>
  <li>What is fold on lists doing?  Visit all the elements applying an accumulating operator</li>
  <li>The idea of Tree fold is to do the same thing on a tree structure</li>
  <li>Here is a simple example derived from the Cornell notes.</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">=</span> 
<span class="o">|</span> <span class="nc">Leaf</span> 
<span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">btree</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="k">rec</span> <span class="n">treefold</span> <span class="n">init</span> <span class="n">op</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="n">init</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="p">(</span><span class="n">v</span><span class="o">,</span><span class="n">l</span><span class="o">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">op</span> <span class="n">v</span> <span class="p">(</span><span class="n">treefold</span> <span class="n">init</span> <span class="n">op</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">treefold</span> <span class="n">init</span> <span class="n">op</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">size</span> <span class="n">t</span> <span class="o">=</span> <span class="n">treefold</span> <span class="mi">0</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="n">t</span>
<span class="k">let</span> <span class="n">depth</span> <span class="n">t</span> <span class="o">=</span> <span class="n">treefold</span> <span class="mi">0</span> <span class="p">(</span><span class="k">fun</span> <span class="n">_</span> <span class="n">l</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="n">t</span>
<span class="k">let</span> <span class="n">preorder</span> <span class="n">t</span> <span class="o">=</span> <span class="n">treefold</span> <span class="bp">[]</span> <span class="p">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">l</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">@</span> <span class="n">l</span> <span class="o">@</span> <span class="n">r</span><span class="p">)</span> <span class="n">t</span>
<span class="k">let</span> <span class="n">tex</span> <span class="o">=</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">6</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">)</span><span class="o">,</span> <span class="nc">Node</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Leaf</span><span class="o">,</span> <span class="nc">Leaf</span><span class="p">))</span>
<span class="n">size</span> <span class="n">tex</span>
</code></pre></div></div>

<h5 id="catamorphism">Catamorphism</h5>

<ul>
  <li>This is a fancy word for a fold over any data type.</li>
  <li>Well it is actually cooler than that, there is some elegant math behind it which can’t easily be coded in in OCaml.</li>
  <li>The essential idea we can express in some OCaml pseudo-code; observe a recursve datatype is a fixed point of a type function:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type function btreefun('mytype)('a) = Leaf | Node of 'a * 'mytype('a) * 'mytype('a) (* takes self-type as arg *)
type 'a btree = btreefun btreefun 'a  (* type fixed point via self-type passing *)
</code></pre></div></div>
<p>By feeding in the “accumulator type” for <code class="highlighter-rouge">'mytype</code> here we can obtain the type of one layer of the fold</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type summer = btreefun int int (* assume we are summating over an integer-node tree *)
</code></pre></div></div>

<p>Then we can write a function over this type which does that one layer:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="n">treesummer</span> <span class="o">:</span> <span class="n">summer</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">-&gt;</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="nc">Node</span> <span class="p">(</span><span class="n">v</span><span class="o">,</span><span class="n">laccum</span><span class="o">,</span><span class="n">raccum</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">v</span> <span class="o">+</span> <span class="n">laccum</span> <span class="o">+</span> <span class="n">raccum</span>

</code></pre></div></div>

<p>And the folder can be generic over any such type – it takes this non-recursive code to perform the fold operation.</p>

<ul>
  <li>See <a href="https://wiki.haskell.org/Catamorphisms">The Haskell Wiki</a> for more information</li>
</ul>

<h4 id="ocaml-functors">OCaml functors</h4>

<ul>
  <li>A “function” from modules to modules</li>
  <li>Allows a module to be parameterized and so instantiated in multiple ways
    <ul>
      <li>think of it as the ability to “plug in” a code module</li>
    </ul>
  </li>
  <li>General functors are found only in a few languages</li>
</ul>

<p>Here is a kind of struct that we can take as a parameter</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">comparison</span> <span class="o">=</span> <span class="nc">LessThan</span> <span class="o">|</span> <span class="nc">EqualTo</span> <span class="o">|</span> <span class="nc">GreaterThan</span> 
 
<span class="k">module</span> <span class="k">type</span> <span class="nc">ORDERED_TYPE</span> <span class="o">=</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">t</span>
    <span class="k">val</span> <span class="n">compare</span><span class="o">:</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">comparison</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Here is a functor version of a set, you feed in a struct with the set element ordering defined on it</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">FSetFunctor</span> <span class="o">=</span>
  <span class="k">functor</span> <span class="p">(</span><span class="nc">Elt</span><span class="o">:</span> <span class="nc">ORDERED_TYPE</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="k">struct</span>
    <span class="k">type</span> <span class="n">element</span> <span class="o">=</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">t</span> <span class="c">(* import the type of elements from the module *)</span>
    <span class="k">type</span> <span class="n">set</span> <span class="o">=</span> <span class="n">element</span> <span class="kt">list</span>

    <span class="k">let</span> <span class="n">empty</span> <span class="o">=</span> <span class="bp">[]</span>

    <span class="k">let</span> <span class="k">rec</span> <span class="n">add</span> <span class="n">x</span> <span class="n">s</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
        <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
      <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span>
          <span class="k">match</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">hd</span> <span class="k">with</span>
            <span class="nc">EqualTo</span>   <span class="o">-&gt;</span> <span class="n">s</span>
          <span class="o">|</span> <span class="nc">LessThan</span>    <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">s</span>
          <span class="o">|</span> <span class="nc">GreaterThan</span> <span class="o">-&gt;</span> <span class="n">hd</span> <span class="o">::</span> <span class="n">add</span> <span class="n">x</span> <span class="n">tl</span>

    <span class="k">let</span> <span class="k">rec</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">s</span> <span class="o">=</span>
      <span class="k">match</span> <span class="n">s</span> <span class="k">with</span>
        <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">false</span>
      <span class="o">|</span> <span class="n">hd</span><span class="o">::</span><span class="n">tl</span> <span class="o">-&gt;</span>
          <span class="k">match</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">compare</span> <span class="n">x</span> <span class="n">hd</span> <span class="k">with</span>
            <span class="nc">EqualTo</span>   <span class="o">-&gt;</span> <span class="bp">true</span>
          <span class="o">|</span> <span class="nc">LessThan</span>    <span class="o">-&gt;</span> <span class="bp">false</span>
          <span class="o">|</span> <span class="nc">GreaterThan</span> <span class="o">-&gt;</span> <span class="n">contains</span> <span class="n">x</span> <span class="n">tl</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Here is a concrete ordering we can feed in, one over ints</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">OrderedInt</span> <span class="o">=</span>
  <span class="k">struct</span>
    <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
    <span class="k">let</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">then</span>
    <span class="nc">EqualTo</span>
      <span class="k">else</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span>
      <span class="nc">LessThan</span>
    <span class="k">else</span>
      <span class="nc">GreaterThan</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Here is how we feed it in, instantiating the functor to give a module</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">OrderedIntSet</span> <span class="o">=</span> <span class="nc">FSetFunctor</span><span class="p">(</span><span class="nc">OrderedInt</span><span class="p">)</span>
</code></pre></div></div>

<p>Example of using the resulting module</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">myOrderedIntSet</span> <span class="o">=</span> <span class="nn">OrderedIntSet</span><span class="p">.</span><span class="n">add</span> <span class="mi">5</span> <span class="nn">OrderedIntSet</span><span class="p">.</span><span class="n">empty</span>
<span class="nn">OrderedIntSet</span><span class="p">.</span><span class="n">contains</span> <span class="mi">3</span> <span class="n">myOrderedIntSet</span>
</code></pre></div></div>

<p>We can do the same thing for a string comparison</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">OrderedString</span> <span class="o">=</span>
<span class="k">struct</span>
  <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">string</span>
  <span class="k">let</span> <span class="n">compare</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">EqualTo</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="k">then</span> <span class="nc">LessThan</span>
    <span class="k">else</span> <span class="nc">GreaterThan</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nc">OrderedStringSet</span> <span class="o">=</span> <span class="nc">FSetFunctor</span><span class="p">(</span><span class="nc">OrderedString</span><span class="p">)</span> <span class="c">(* a DIFFERENT instantiation of same *)</span>

<span class="k">let</span> <span class="n">myOrderedStringSet</span> <span class="o">=</span> <span class="nn">OrderedStringSet</span><span class="p">.</span><span class="n">add</span> <span class="s2">"abc"</span> <span class="nn">OrderedStringSet</span><span class="p">.</span><span class="n">empty</span>
</code></pre></div></div>

<p>Functors also have signatures; there can also be type abstraction in a functor signature</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="k">type</span> <span class="nc">SETFUNCTOR</span> <span class="o">=</span> <span class="c">(* below is the syntax for a signature of a functor *)</span>
    <span class="k">functor</span> <span class="p">(</span><span class="nc">Elt</span><span class="o">:</span> <span class="nc">ORDERED_TYPE</span><span class="p">)</span> <span class="o">-&gt;</span>
  <span class="k">sig</span>
    <span class="k">type</span> <span class="n">element</span> <span class="o">=</span> <span class="nn">Elt</span><span class="p">.</span><span class="n">t</span>      <span class="c">(* concrete *)</span>
    <span class="k">type</span> <span class="n">set</span>                  <span class="c">(* abstract *)</span>
    <span class="k">val</span> <span class="n">empty</span> <span class="o">:</span> <span class="n">set</span>
    <span class="k">val</span> <span class="n">add</span> <span class="o">:</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="o">-&gt;</span> <span class="n">set</span>
    <span class="k">val</span> <span class="n">contains</span> <span class="o">:</span> <span class="n">element</span> <span class="o">-&gt;</span> <span class="n">set</span> <span class="o">-&gt;</span> <span class="kt">bool</span>
  <span class="k">end</span>

<span class="k">module</span> <span class="nc">AbstractSet</span> <span class="o">=</span> <span class="p">(</span><span class="nc">FSetFunctor</span> <span class="o">:</span> <span class="nc">SETFUNCTOR</span><span class="p">)</span> <span class="c">(* slap that sig on a functor *)</span>
<span class="k">module</span> <span class="nc">AbstractIntSet</span> <span class="o">=</span> <span class="nc">AbstractSet</span><span class="p">(</span><span class="nc">OrderedInt</span><span class="p">)</span>

<span class="nn">AbstractIntSet</span><span class="p">.</span><span class="n">add</span> <span class="mi">5</span> <span class="nn">AbstractIntSet</span><span class="p">.</span><span class="n">empty</span>
</code></pre></div></div>

<ul>
  <li>Observe the internal structure is hidden since the type list was hidden</li>
  <li>This is called an <em>existential type</em>:  a type exists, we just don’t know what it is.</li>
</ul>

<h5 id="functors-in-the-standard-library">Functors in the Standard Library</h5>

<p><code class="highlighter-rouge">Stdlib.Set</code> uses functors similar to how our simplistic set works, let us review it – <a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.html">manpage</a></p>

<p>Usage example</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nc">Ints</span> <span class="o">=</span>
       <span class="k">struct</span>
         <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span>
         <span class="k">let</span> <span class="n">compare</span> <span class="n">x0</span> <span class="n">x1</span> <span class="o">=</span>
           <span class="nn">Stdlib</span><span class="p">.</span><span class="n">compare</span> <span class="n">x0</span> <span class="n">x1</span>
       <span class="k">end</span>

     <span class="k">module</span> <span class="nc">IntsSet</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="nc">Make</span><span class="p">(</span><span class="nc">Ints</span><span class="p">)</span> <span class="c">(* Set.Make is a functor *)</span>

     <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">IntsSet</span><span class="p">.(</span><span class="n">empty</span> <span class="o">|&gt;</span> <span class="n">add</span> <span class="mi">3</span> <span class="o">|&gt;</span> <span class="n">add</span> <span class="mi">22</span> <span class="o">|&gt;</span> <span class="n">add</span> <span class="mi">76</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p><a href="https://dev.realworldocaml.org/functors.html">Real World OCaml</a> has more involved examples</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">fbdk/src/application.ml</code> in FbDK is yet another example; e.g. <code class="highlighter-rouge">Fb/fb.ml</code> uses a functor.</p>
  </li>
</ul>

<h5 id="first-class-modules">First-class modules</h5>

<p>Idea: Lift modules to be true first-class data; supported in more recent OCaml versions.</p>

<ul>
  <li>See <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual028.html">the manual</a> for documentation</li>
  <li>Allows modules to be constructed and composed based on run-time data</li>
  <li>Allows modules to be placed in data structures, e.g. a list of Set’s.</li>
  <li>Allows functors to be written which are ordinary functions (not as powerful as actual functors though)</li>
  <li><a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual028.html">Example in OCaml manual</a> shows how to build a Set-making function</li>
  <li>See <a href="https://dev.realworldocaml.org/first-class-modules.html">Real-World OCaml</a> for more info on first-class modules, the manual is pretty minimal</li>
</ul>

<h4 id="gadts-in-ocaml">GADTs in OCaml</h4>

<p>Generalized Abstract Data Types (GADT’s) allow several more flexible uses of OCaml data types.  See <a href="https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html">The Manual</a> for the details.</p>

<h5 id="new-data-type-syntax-for-ocaml">New data type syntax for OCaml</h5>

<p>Review: roll-your-own lists using existing OCaml types</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">'</span><span class="n">a</span> <span class="n">oldlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="k">of</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">oldlist</span>
</code></pre></div></div>

<p>Equivalent way to do list type using new generic type syntax (but using it to do old thing)</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span> <span class="o">|</span> <span class="nc">Cons</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
</code></pre></div></div>

<ul>
  <li>Observe how this is writing out the constructors with what their types are, viewing constructors as functions (they still are not functions in OCaml, but they are closer to being so)</li>
  <li>This type will work at least as well as the original <code class="highlighter-rouge">oldlist</code> type.</li>
</ul>

<p>Lets now show some added power of this new notation (toy example).</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
<span class="o">|</span> <span class="nc">IntNil</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">newlist</span>
<span class="o">|</span> <span class="nc">Cons</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
</code></pre></div></div>

<p>We now have a new IntNil empty list, which is only consable on to integers:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">IntNil</span><span class="p">);;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Cons</span> <span class="p">(</span><span class="mi">5</span><span class="o">,</span> <span class="nc">IntNil</span><span class="p">)</span>
</code></pre></div></div>

<p>Note however that “IntNil” is just a name, the int newlist type could have been something else:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">newlist</span> <span class="o">=</span> <span class="nc">Nil</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
<span class="o">|</span> <span class="nc">IntNil</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">newlist</span> <span class="c">(* yes this is perfectly legal *)</span>
<span class="o">|</span> <span class="nc">Cons</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">newlist</span>
</code></pre></div></div>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">Cons</span><span class="p">(</span><span class="mi">5</span><span class="o">,</span><span class="nc">IntNil</span><span class="p">);;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">expression</span> <span class="n">has</span> <span class="k">type</span> <span class="kt">string</span> <span class="n">newlist</span>
       <span class="n">but</span> <span class="n">an</span> <span class="n">expression</span> <span class="n">was</span> <span class="n">expected</span> <span class="k">of</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">newlist</span>
       <span class="nc">Type</span> <span class="kt">string</span> <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="kt">int</span>
</code></pre></div></div>

<p>In other words, the “IntNil” is just a name.  It is <em>axiomatically</em> (by fiat) making certain constructors have certain newlist types.  Think of it as something like making an operational semantics rule set.  Here is an arbitrary example to illustrate.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">dough</span> <span class="o">=</span> 
  <span class="nc">Coin</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="c">(* base case (axiom) *)</span>
<span class="o">|</span> <span class="nc">Add</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="c">(* rule: have dough, can make more same type of dough *)</span>
<span class="o">|</span> <span class="nc">Bump</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="kt">float</span> <span class="n">dough</span> <span class="c">(* rule: can turn int dough to float dough *)</span>
<span class="o">|</span> <span class="nc">Morph</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span> <span class="n">dough</span> <span class="c">(* rule: can turn any kind of dough to any other *)</span>
<span class="o">|</span> <span class="nc">Intbux</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">dough</span> <span class="c">(* rule: with a number some int dough can be made *)</span>
<span class="o">|</span> <span class="nc">Intcomb</span> <span class="o">:</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="n">dough</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">dough</span> <span class="c">(* rule: use int and int dough to make int dough *)</span>
</code></pre></div></div>

<p>You can still do whatever combinations will type, e.g.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">Bump</span><span class="p">(</span><span class="nc">Add</span><span class="p">(</span><span class="nc">Coin</span><span class="p">));;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">dough</span> <span class="o">=</span> <span class="nc">Bump</span> <span class="p">(</span><span class="nc">Add</span> <span class="nc">Coin</span><span class="p">)</span>
<span class="o">#</span> <span class="nc">Bump</span><span class="p">(</span><span class="nc">Morph</span><span class="p">(</span><span class="nc">Bump</span><span class="p">(</span><span class="nc">Add</span><span class="p">(</span><span class="nc">Intcomb</span><span class="p">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">Coin</span><span class="p">)))));;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">float</span> <span class="n">dough</span> <span class="o">=</span> <span class="nc">Bump</span> <span class="p">(</span><span class="nc">Morph</span> <span class="p">(</span><span class="nc">Bump</span> <span class="p">(</span><span class="nc">Add</span> <span class="p">(</span><span class="nc">Intcomb</span> <span class="p">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">Coin</span><span class="p">)))))</span>
</code></pre></div></div>

<ul>
  <li>The above type has no purpose: it is like making some random (well-formed) operational semantics rules, they are not likely to be useful.</li>
  <li>As with an operational semantics rule set, with the right set of rules you can do interesting stuff.</li>
</ul>

<h5 id="explicit-forall-types">Explicit forall types</h5>

<p>Along with the new syntax for type declarations is new syntax for polymorphic (for all / generic) types.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">id</span><span class="o">:</span> <span class="k">type</span> <span class="n">t</span><span class="o">.</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="p">;;</span>
<span class="k">val</span> <span class="n">id</span> <span class="o">:</span> <span class="k">'</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li>This type syntax is better in that it makes it more explicit that the type is “for all types t, t to t”.</li>
  <li>But, a big downside of all this is you need to start declaring types for OCaml functions as we will see below.</li>
  <li>These types are a form of the <a href="https://caml.inria.fr/pub/docs/manual-ocaml/manual027.html">locally abstract types</a> in OCaml.</li>
</ul>

<h5 id="useful-work-from-the-new-gadts-in-ocaml">Useful work from the new GADT’s in OCaml</h5>

<p>Here is an example from the manual showing how some useful work can be done.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">type</span> <span class="n">_</span> <span class="n">typ</span> <span class="o">=</span>
   <span class="o">|</span> <span class="nc">Int</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span>      <span class="c">(* axiom: make an int type *)</span>
   <span class="o">|</span> <span class="nc">String</span> <span class="o">:</span> <span class="kt">string</span> <span class="n">typ</span> <span class="c">(* axiom: can make a string typ *)</span>
   <span class="o">|</span> <span class="nc">Pair</span> <span class="o">:</span> <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">typ</span> <span class="c">(* rule: from any two typ's can make their product *)</span>
</code></pre></div></div>

<p>Observe first that this GADT <code class="highlighter-rouge">typ</code> is not the same as the “old OCaml” equivalent,</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">atype</span> <span class="o">=</span> <span class="nc">OInt</span> <span class="o">|</span> <span class="nc">OString</span> <span class="o">|</span> <span class="nc">OPair</span> <span class="k">of</span> <span class="n">atype</span> <span class="o">*</span> <span class="n">atype</span>
</code></pre></div></div>
<p>– the old types are much simpler, there is no type parameter; compare:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">#</span> <span class="nc">OPair</span><span class="p">(</span><span class="nc">OInt</span><span class="o">,</span><span class="nc">OString</span><span class="p">);;</span> <span class="c">(* old *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="n">atype</span> <span class="o">=</span> <span class="nc">OPair</span> <span class="p">(</span><span class="nc">OInt</span><span class="o">,</span> <span class="nc">OString</span><span class="p">)</span>           <span class="c">(* no parameter on atype *)</span>
<span class="o">#</span> <span class="nc">Pair</span><span class="p">(</span><span class="nc">Int</span><span class="o">,</span><span class="nc">String</span><span class="p">);;</span>    <span class="c">(* new *)</span>
<span class="o">-</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span><span class="p">)</span> <span class="n">typ</span> <span class="o">=</span> <span class="nc">Pair</span> <span class="p">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">String</span><span class="p">)</span> <span class="c">(* observe parameter on typ *)</span>
</code></pre></div></div>

<p>The interesting and useful bit about this seemingly-useless difference is this type parameter on <code class="highlighter-rouge">typ</code> can be used to type otherwise untypeable code:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="k">rec</span> <span class="n">to_string</span><span class="o">:</span> <span class="k">type</span> <span class="n">t</span><span class="o">.</span> <span class="n">t</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="c">(* notice need to declare forall types! *)</span>
   <span class="k">fun</span> <span class="n">tv</span> <span class="n">x</span> <span class="o">-&gt;</span>
   <span class="k">match</span> <span class="n">tv</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Int</span> <span class="o">-&gt;</span> <span class="n">string_of_int</span> <span class="n">x</span>
   <span class="o">|</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"%S"</span> <span class="n">x</span>
   <span class="o">|</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">let</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="k">in</span>
       <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"(%s,%s)"</span> <span class="p">(</span><span class="n">to_string</span> <span class="n">t1</span> <span class="n">x1</span><span class="p">)</span> <span class="p">(</span><span class="n">to_string</span> <span class="n">t2</span> <span class="n">x2</span><span class="p">);;</span>
<span class="k">val</span> <span class="n">to_string</span> <span class="o">:</span> <span class="k">'</span><span class="n">t</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">t</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">&lt;</span><span class="k">fun</span><span class="o">&gt;</span>
</code></pre></div></div>

<ul>
  <li>Here <code class="highlighter-rouge">typ</code> is giving a run-time name, <code class="highlighter-rouge">Int</code> which in the type of <code class="highlighter-rouge">to_string</code> adds an implicit constraint that the second argument <em>must be an integer</em> (cool, eh?).</li>
  <li>Notice that the whole <code class="highlighter-rouge">match</code> above cannot be typed at a fixed type for <code class="highlighter-rouge">tv</code> like <code class="highlighter-rouge">int typ</code></li>
  <li>The type used in each branch clause <em>depends</em> on which constuctor we are using</li>
  <li>this is sometimes called a <em>weak dependent type</em> but it is really a <em>path-sensitive type</em>: different paths through the function can have different types.</li>
  <li>Additionally, notice that the recursive call for pairs is at a type different than the original parameter – this is called a <em>polymorphic recursive type</em> and is not supported in normal OCaml types.</li>
  <li>This allows run-time type dispatch to be encoded</li>
  <li>This trick is in fact how the OCaml libraries implement printf.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># to_string Int 5;; (* Int has type int typ and 5 is of type int -- a match *)
- : string = "5"
# to_string Int "oops";; (* Int has type int typ and "oops" is of type string -- mismatch *)
Error: This expression has type string but an expression was expected of type
         int
</code></pre></div></div>

<p>If the type of <code class="highlighter-rouge">to_string</code> were the more standard OCaml <code class="highlighter-rouge">'a typ -&gt; 'a -&gt; string</code> this path-sensitivity would not be allowed:</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">let</span> <span class="k">rec</span> <span class="n">too_string</span><span class="o">:</span>  <span class="k">'</span><span class="n">a</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span>
   <span class="k">fun</span> <span class="n">tv</span> <span class="n">x</span> <span class="o">-&gt;</span>
   <span class="k">match</span> <span class="n">tv</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Int</span> <span class="o">-&gt;</span> <span class="n">string_of_int</span> <span class="n">x</span>
   <span class="o">|</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"%S"</span> <span class="n">x</span>
   <span class="o">|</span> <span class="nc">Pair</span><span class="p">(</span><span class="n">t1</span><span class="o">,</span><span class="n">t2</span><span class="p">)</span> <span class="o">-&gt;</span>
       <span class="k">let</span> <span class="p">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span> <span class="n">x</span> <span class="k">in</span>
       <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">"(%s,%s)"</span> <span class="p">(</span><span class="n">to_string</span> <span class="n">t1</span> <span class="n">x1</span><span class="p">)</span> <span class="p">(</span><span class="n">to_string</span> <span class="n">t2</span> <span class="n">x2</span><span class="p">);;</span>
<span class="nc">Error</span><span class="o">:</span> <span class="nc">This</span> <span class="n">pattern</span> <span class="n">matches</span> <span class="n">values</span> <span class="k">of</span> <span class="k">type</span> <span class="kt">string</span> <span class="n">typ</span>
       <span class="n">but</span> <span class="n">a</span> <span class="n">pattern</span> <span class="n">was</span> <span class="n">expected</span> <span class="n">which</span> <span class="n">matches</span> <span class="n">values</span> <span class="k">of</span> <span class="k">type</span> <span class="kt">int</span> <span class="n">typ</span>
       <span class="nc">Type</span> <span class="kt">string</span> <span class="n">is</span> <span class="n">not</span> <span class="n">compatible</span> <span class="k">with</span> <span class="k">type</span> <span class="kt">int</span> 
</code></pre></div></div>

<ul>
  <li>From the first match case <code class="highlighter-rouge">'a</code> must be an integer, but that conflicts with the second case.  GADTs allow each branch to have it’s own type.</li>
  <li>Notice also that any cases from a GADT which do not type-check can be elided since the type system knows that case will never be matched</li>
  <li>For example the following typechecks in spite of missing cases:</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">int_to_string</span><span class="o">:</span> <span class="kt">int</span> <span class="n">typ</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">-&gt;</span> <span class="kt">string</span> <span class="o">=</span>
   <span class="k">fun</span> <span class="n">t</span> <span class="n">x</span> <span class="o">-&gt;</span>
   <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
   <span class="o">|</span> <span class="nc">Int</span> <span class="o">-&gt;</span> <span class="n">string_of_int</span> <span class="n">x</span>
</code></pre></div></div>

<p>Here is another simple example of suspended application.</p>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">_</span> <span class="n">wait</span> <span class="o">=</span>  <span class="nc">Wait</span> <span class="o">:</span> <span class="k">'</span><span class="n">arg</span> <span class="o">*</span> <span class="p">(</span><span class="k">'</span><span class="n">arg</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">result</span> <span class="n">wait</span>
<span class="k">let</span> <span class="n">foo</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="k">then</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
<span class="k">let</span> <span class="n">suspended_value</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">wait</span> <span class="o">=</span> <span class="nc">Wait</span><span class="p">(</span><span class="bp">true</span><span class="o">,</span> <span class="n">foo</span><span class="p">)</span>
<span class="k">let</span> <span class="n">other_suspended_value</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">wait</span> <span class="o">=</span> <span class="nc">Wait</span><span class="p">(</span><span class="s2">"5"</span><span class="o">,</span> <span class="n">int_of_string</span><span class="p">)</span>
<span class="k">let</span> <span class="n">run_it</span> <span class="n">w</span> <span class="o">=</span> <span class="k">match</span> <span class="n">w</span> <span class="k">with</span> <span class="nc">Wait</span><span class="p">(</span><span class="n">arg</span><span class="o">,</span><span class="n">func</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">func</span> <span class="n">arg</span>
<span class="k">let</span> <span class="n">doit</span> <span class="o">=</span> <span class="n">run_it</span> <span class="n">suspended_value</span>
</code></pre></div></div>

<ul>
  <li>Observe that the type <code class="highlighter-rouge">'arg</code> is not an exposed parameter in the wait type like <code class="highlighter-rouge">'result</code> is</li>
  <li>It is an <em>existential</em> type, there is <em>some</em> type that works there but it is hidden in the <code class="highlighter-rouge">wait</code> type.</li>
  <li>Such types cannot be formed in the “old” OCaml type syntax</li>
  <li>The above code in fact would work with a regular OCaml <code class="highlighter-rouge">Wait</code> type but we could not make a list of the two <code class="highlighter-rouge">int wait</code> values above as their <code class="highlighter-rouge">'arg</code> types differ</li>
</ul>

<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span><span class="o">,</span> <span class="k">'</span><span class="n">b</span><span class="p">)</span> <span class="n">badwait</span> <span class="o">=</span>  <span class="nc">BadWait</span> <span class="k">of</span>  <span class="k">'</span><span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="k">'</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">'</span><span class="n">b</span><span class="p">);;</span> <span class="c">(* notice how BOTH 'a and 'b exposed here *)</span>
</code></pre></div></div>

<p>A practical library example: <a href="https://github.com/hannesm/gmap">Gmap</a></p>

